<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoadingIndicator Shapes Review</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 40px;
            font-size: 1.2em;
        }
        
        .shapes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .shape-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .shape-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border-color: #667eea;
        }
        
        .shape-canvas {
            width: 80px;
            height: 80px;
            margin: 0 auto 15px;
            border-radius: 8px;
            background: #fff;
            border: 1px solid #dee2e6;
        }
        
        .shape-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        
        .shape-index {
            color: #6c757d;
            font-size: 0.9em;
            position: absolute;
            top: 10px;
            right: 15px;
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 500;
        }
        
        .instructions {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .instructions h3 {
            margin-top: 0;
            color: #1976d2;
        }
        
        .theme-toggle {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .theme-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            margin: 0 10px;
            transition: all 0.3s ease;
        }
        
        .theme-btn:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }
        
        .theme-btn.active {
            background: #4caf50;
        }
        
        .dark-theme {
            background: #2c3e50;
        }
        
        .dark-theme .container {
            background: #34495e;
            color: #ecf0f1;
        }
        
        .dark-theme .shape-card {
            background: #3c5470;
            border-color: #4a6584;
        }
        
        .dark-theme .shape-canvas {
            background: #2c3e50;
            border-color: #4a6584;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® LoadingIndicator Shapes Review</h1>
        <p class="subtitle">All shapes from the enhanced loading indicator</p>
        
        <div class="instructions">
            <h3>üìã Review Instructions</h3>
            <p>Each shape is rendered exactly as it appears in the LoadingIndicator component. Review each one and let me know which shapes to:</p>
            <ul>
                <li><strong>Keep</strong> - Shape looks good as-is</li>
                <li><strong>Modify</strong> - Shape needs adjustments (specify what changes)</li>
                <li><strong>Delete</strong> - Shape should be removed from the collection</li>
            </ul>
        </div>
        
        <div class="theme-toggle">
            <button class="theme-btn active" onclick="setTheme('light')">‚òÄÔ∏è Light Theme</button>
            <button class="theme-btn" onclick="setTheme('dark')">üåô Dark Theme</button>
        </div>
        
        <div class="shapes-grid" id="shapesGrid">
            <!-- Shapes will be dynamically generated here -->
        </div>
    </div>

    <script type="module">
        // Import the actual LoadingIndicator modules
        import { Point } from '../src/components/common/LoadingIndicator/utils.js';
        import { Cubic } from '../src/components/common/LoadingIndicator/cubic.js';
        import { RoundedPolygon } from '../src/components/common/LoadingIndicator/roundedPolygon.js';

        // Updated collection of shapes (removed unwanted ones)
        const shapeDefinitions = [
            { name: "Triangle", index: 0 },
            { name: "Square", index: 1 },
            { name: "Pentagon", index: 2 },
            { name: "5-pointed Star", index: 3 },
            { name: "Hexagon", index: 4 },
            { name: "Octagon", index: 5 },
            { name: "6-pointed Star", index: 6 },
            { name: "Diamond", index: 7 },
            { name: "Cross/Plus", index: 8 },
            { name: "Arrow", index: 9 },
            { name: "4-pointed Star", index: 10 },
            { name: "Oval (Improved)", index: 11 },
            { name: "Teardrop (Improved)", index: 12 },
            { name: "Crescent Moon", index: 13 },
            { name: "Flower", index: 14 },
            { name: "House", index: 15 },
            { name: "Spade (Improved)", index: 16 },
            { name: "Infinity (Improved)", index: 17 },
            { name: "Gear", index: 18 },
            { name: "Sun", index: 19 },
            { name: "Bolt", index: 20 },
            { name: "Wave", index: 21 },
            { name: "Ring (Fixed)", index: 22 },
            { name: "Pill", index: 23 },
            { name: "Bone", index: 24 },
            { name: "Mountain", index: 25 },
            { name: "Fish", index: 26 },
            { name: "Tree", index: 27 },
            { name: "Cactus", index: 28 },
            { name: "Cup (Wide Bottom)", index: 29 },
            { name: "Bottle", index: 30 },
            { name: "Book", index: 31 },
            { name: "Phone", index: 32 },
            { name: "Laptop (Wide Bottom)", index: 33 },
            { name: "Camera", index: 34 },
            { name: "Puzzle Piece (Simple)", index: 35 },
            { name: "Anchor", index: 36 },
            { name: "Crown", index: 37 },
            { name: "8-pointed Star", index: 38 }
        ];

        let currentTheme = 'light';

        // Define setTheme function in global scope
        window.setTheme = function(theme) {
            currentTheme = theme;
            document.body.className = theme === 'dark' ? 'dark-theme' : '';
            
            // Update button states
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Re-render shapes with new theme
            renderShapes();
        };

        // Actual shape creation functions from LoadingIndicator.js
        function createCirclePolygon(radius, sides, RoundedPolygon) {
            const vertices = new Float32Array(sides * 2);
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI;
                vertices[i * 2] = Math.cos(angle) * radius;
                vertices[i * 2 + 1] = Math.sin(angle) * radius;
            }
            return new RoundedPolygon(vertices, 3);
        }

        function createStarPolygon(radius, points, RoundedPolygon) {
            const vertices = new Float32Array(points * 4);
            const innerRadius = radius * 0.4;
            let vertexIndex = 0;

            for (let i = 0; i < points; i++) {
                const outerAngle = (i / points) * 2 * Math.PI - Math.PI / 2;
                vertices[vertexIndex++] = Math.cos(outerAngle) * radius;
                vertices[vertexIndex++] = Math.sin(outerAngle) * radius;

                const innerAngle = ((i + 0.5) / points) * 2 * Math.PI - Math.PI / 2;
                vertices[vertexIndex++] = Math.cos(innerAngle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(innerAngle) * innerRadius;
            }
            return new RoundedPolygon(vertices, 2);
        }

        // All the additional shape creation functions from LoadingIndicator
        function createDiamondShape(size, RoundedPolygon) {
            const vertices = new Float32Array([0, -size, size, 0, 0, size, -size, 0]);
            return new RoundedPolygon(vertices, 4);
        }

        function createCrossShape(size, RoundedPolygon) {
            const thickness = size * 0.3;
            const vertices = new Float32Array([
                -thickness, -size, thickness, -size, thickness, -thickness,
                size, -thickness, size, thickness, thickness, thickness,
                thickness, size, -thickness, size, -thickness, thickness,
                -size, thickness, -size, -thickness, -thickness, -thickness
            ]);
            return new RoundedPolygon(vertices, 3);
        }

        function createArrowShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                0, -size, size * 0.5, -size * 0.3, size * 0.2, -size * 0.3,
                size * 0.2, size, -size * 0.2, size, -size * 0.2, -size * 0.3,
                -size * 0.5, -size * 0.3
            ]);
            return new RoundedPolygon(vertices, 3);
        }

        function createOvalShape(width, height, RoundedPolygon) {
            const sides = 24; // More sides for smoother oval
            const vertices = new Float32Array(sides * 2);
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI;
                vertices[i * 2] = Math.cos(angle) * width;
                vertices[i * 2 + 1] = Math.sin(angle) * height;
            }
            return new RoundedPolygon(vertices, 1); // Less rounding for smoother curves
        }

        function createTearDropShape(size, RoundedPolygon) {
            // Realistic teardrop shape with smooth curves
            const vertices = new Float32Array([
                0, -size, // Sharp point at top
                size * 0.5, -size * 0.6, // Right side curve
                size * 0.8, -size * 0.1, // Right bulge
                size * 0.9, size * 0.3, // Right bottom
                size * 0.6, size * 0.7, // Right bottom curve
                size * 0.2, size * 0.9, // Bottom right
                0, size, // Bottom center
                -size * 0.2, size * 0.9, // Bottom left
                -size * 0.6, size * 0.7, // Left bottom curve
                -size * 0.9, size * 0.3, // Left bottom
                -size * 0.8, -size * 0.1, // Left bulge
                -size * 0.5, -size * 0.6 // Left side curve
            ]);
            return new RoundedPolygon(vertices, 6); // Higher rounding for smooth teardrop
        }

        // Add the remaining shape creation functions
        function createMoonShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                size * 0.5, -size * 0.8, size * 0.8, -size * 0.3, size * 0.6, 0,
                size * 0.8, size * 0.3, size * 0.5, size * 0.8, 0, size * 0.5,
                -size * 0.3, size * 0.2, -size * 0.5, 0, -size * 0.3, -size * 0.2,
                0, -size * 0.5
            ]);
            return new RoundedPolygon(vertices, 5);
        }

        function createFlowerShape(size, RoundedPolygon) {
            const petals = 8;
            const vertices = new Float32Array(petals * 4);
            let vertexIndex = 0;

            for (let i = 0; i < petals; i++) {
                const angle = (i / petals) * 2 * Math.PI;
                const petalTipX = Math.cos(angle) * size;
                const petalTipY = Math.sin(angle) * size;
                const petalBaseX = Math.cos(angle) * size * 0.3;
                const petalBaseY = Math.sin(angle) * size * 0.3;

                vertices[vertexIndex++] = petalTipX;
                vertices[vertexIndex++] = petalTipY;
                vertices[vertexIndex++] = petalBaseX;
                vertices[vertexIndex++] = petalBaseY;
            }
            return new RoundedPolygon(vertices, 6);
        }

        function createHouseShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                0, -size, size * 0.7, -size * 0.3, size * 0.7, size * 0.2,
                size * 0.7, size * 0.8, -size * 0.7, size * 0.8, -size * 0.7, size * 0.2,
                -size * 0.7, -size * 0.3
            ]);
            return new RoundedPolygon(vertices, 5);
        }

        function createSpadeShape(size, RoundedPolygon) {
            // Smooth spade card suit
            const vertices = new Float32Array([
                0, -size, // Top point
                size * 0.4, -size * 0.6, // Right top curve
                size * 0.7, -size * 0.2, // Right side
                size * 0.8, size * 0.1, // Right bulge
                size * 0.6, size * 0.4, // Right bottom curve
                size * 0.3, size * 0.5, // Right stem connection
                size * 0.25, size * 0.7, // Right stem
                size * 0.15, size * 0.9, // Right stem bottom
                0, size, // Bottom center
                -size * 0.15, size * 0.9, // Left stem bottom
                -size * 0.25, size * 0.7, // Left stem
                -size * 0.3, size * 0.5, // Left stem connection
                -size * 0.6, size * 0.4, // Left bottom curve
                -size * 0.8, size * 0.1, // Left bulge
                -size * 0.7, -size * 0.2, // Left side
                -size * 0.4, -size * 0.6 // Left top curve
            ]);
            return new RoundedPolygon(vertices, 5); // Higher rounding for smooth curves
        }

        function createInfinityShape(size, RoundedPolygon) {
            // Smooth infinity symbol (figure-8) with more natural curves
            const vertices = new Float32Array([
                -size * 0.9, 0, // Left outer point
                -size * 0.7, -size * 0.3, // Left top curve
                -size * 0.4, -size * 0.4, // Left top inner
                -size * 0.1, -size * 0.3, // Center top left
                0, 0, // Center crossing
                size * 0.1, -size * 0.3, // Center top right
                size * 0.4, -size * 0.4, // Right top inner
                size * 0.7, -size * 0.3, // Right top curve
                size * 0.9, 0, // Right outer point
                size * 0.7, size * 0.3, // Right bottom curve
                size * 0.4, size * 0.4, // Right bottom inner
                size * 0.1, size * 0.3, // Center bottom right
                0, 0, // Center crossing (duplicate for smooth path)
                -size * 0.1, size * 0.3, // Center bottom left
                -size * 0.4, size * 0.4, // Left bottom inner
                -size * 0.7, size * 0.3 // Left bottom curve
            ]);
            return new RoundedPolygon(vertices, 8); // High rounding for smooth infinity curves
        }

        function createGearShape(size, RoundedPolygon) {
            const teeth = 8;
            const innerRadius = size * 0.6;
            const outerRadius = size;
            const vertices = new Float32Array(teeth * 4);
            let vertexIndex = 0;

            for (let i = 0; i < teeth; i++) {
                const baseAngle = (i / teeth) * 2 * Math.PI;
                const toothAngle = ((i + 0.5) / teeth) * 2 * Math.PI;

                vertices[vertexIndex++] = Math.cos(baseAngle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(baseAngle) * innerRadius;

                vertices[vertexIndex++] = Math.cos(toothAngle) * outerRadius;
                vertices[vertexIndex++] = Math.sin(toothAngle) * outerRadius;
            }
            return new RoundedPolygon(vertices, 2);
        }

        // Add all the new shape functions
        function createSunShape(size, RoundedPolygon) {
            const rays = 12;
            const innerRadius = size * 0.5;
            const outerRadius = size;
            const vertices = new Float32Array(rays * 4);
            let vertexIndex = 0;

            for (let i = 0; i < rays; i++) {
                const baseAngle = (i / rays) * 2 * Math.PI;
                const rayAngle = ((i + 0.5) / rays) * 2 * Math.PI;

                vertices[vertexIndex++] = Math.cos(baseAngle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(baseAngle) * innerRadius;

                vertices[vertexIndex++] = Math.cos(rayAngle) * outerRadius;
                vertices[vertexIndex++] = Math.sin(rayAngle) * outerRadius;
            }
            return new RoundedPolygon(vertices, 4);
        }



        function createBoltShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                0, -size, size * 0.3, -size * 0.7, size * 0.2, -size * 0.3,
                size * 0.4, -size * 0.1, size * 0.2, size * 0.1, size * 0.4, size * 0.3,
                size * 0.2, size * 0.5, size * 0.4, size * 0.7, size * 0.2, size,
                -size * 0.2, size, -size * 0.4, size * 0.7, -size * 0.2, size * 0.5,
                -size * 0.4, size * 0.3, -size * 0.2, size * 0.1, -size * 0.4, -size * 0.1,
                -size * 0.2, -size * 0.3, -size * 0.3, -size * 0.7
            ]);
            return new RoundedPolygon(vertices, 2);
        }

        // Removed unused shape functions (leaf, eye, crescent, key, lock, bird, rocket)
        function createWaveShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size, 0, -size * 0.7, -size * 0.5, -size * 0.3, -size * 0.3, 0, -size * 0.6, size * 0.3, -size * 0.3, size * 0.7, -size * 0.5, size, 0, size * 0.7, size * 0.5, size * 0.3, size * 0.3, 0, size * 0.6, -size * 0.3, size * 0.3, -size * 0.7, size * 0.5]);
            return new RoundedPolygon(vertices, 7);
        }
        function createRingShape(size, RoundedPolygon) {
            const outerSides = 20;
            const innerRadius = size * 0.5;
            const vertices = new Float32Array(outerSides * 4);
            let vertexIndex = 0;

            for (let i = 0; i < outerSides; i++) {
                const angle = (i / outerSides) * 2 * Math.PI;
                // Outer circle
                vertices[vertexIndex++] = Math.cos(angle) * size;
                vertices[vertexIndex++] = Math.sin(angle) * size;
                // Inner circle
                vertices[vertexIndex++] = Math.cos(angle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(angle) * innerRadius;
            }
            return new RoundedPolygon(vertices, 4);
        }
        function createPillShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size * 0.5, -size, size * 0.5, -size, size, -size * 0.5, size, size * 0.5, size * 0.5, size, -size * 0.5, size, -size, size * 0.5, -size, -size * 0.5]);
            return new RoundedPolygon(vertices, 8);
        }
        function createBoneShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size * 0.8, -size * 0.3, -size * 0.6, -size * 0.6, -size * 0.3, -size * 0.4, -size * 0.1, -size * 0.2, size * 0.1, -size * 0.2, size * 0.3, -size * 0.4, size * 0.6, -size * 0.6, size * 0.8, -size * 0.3, size * 0.8, size * 0.3, size * 0.6, size * 0.6, size * 0.3, size * 0.4, size * 0.1, size * 0.2, -size * 0.1, size * 0.2, -size * 0.3, size * 0.4, -size * 0.6, size * 0.6, -size * 0.8, size * 0.3]);
            return new RoundedPolygon(vertices, 4);
        }

        function createMountainShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size, size, -size * 0.6, size * 0.2, -size * 0.3, -size * 0.8, 0, -size * 0.4, size * 0.3, -size, size * 0.6, size * 0.2, size, size]);
            return new RoundedPolygon(vertices, 3);
        }
        function createFishShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size, 0, -size * 0.7, -size * 0.3, -size * 0.4, -size * 0.2, size * 0.2, -size * 0.4, size * 0.8, -size * 0.2, size, 0, size * 0.8, size * 0.2, size * 0.2, size * 0.4, -size * 0.4, size * 0.2, -size * 0.7, size * 0.3]);
            return new RoundedPolygon(vertices, 4);
        }

        function createTreeShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size * 0.1, size, -size * 0.1, size * 0.3, -size * 0.6, size * 0.2, -size * 0.7, -size * 0.2, -size * 0.3, -size * 0.8, 0, -size, size * 0.3, -size * 0.8, size * 0.7, -size * 0.2, size * 0.6, size * 0.2, size * 0.1, size * 0.3, size * 0.1, size]);
            return new RoundedPolygon(vertices, 5);
        }

        // Add remaining simple shapes
        function createCactusShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.2, size, -size * 0.2, -size * 0.2, -size * 0.6, -size * 0.4, -size * 0.6, -size * 0.8, -size * 0.4, -size * 0.8, -size * 0.4, -size * 0.4, -size * 0.1, -size * 0.4, -size * 0.1, -size, size * 0.1, -size, size * 0.1, -size * 0.4, size * 0.4, -size * 0.4, size * 0.4, -size * 0.8, size * 0.6, -size * 0.8, size * 0.6, -size * 0.4, size * 0.2, -size * 0.2, size * 0.2, size]), 4); }

        function createCupShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.4, -size, // Top left
                size * 0.4, -size, // Top right
                size * 0.8, size * 0.8, // Bottom right (wider)
                -size * 0.8, size * 0.8 // Bottom left (wider)
            ]);
            return new RoundedPolygon(vertices, 6);
        }
        function createBottleShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.2, -size, size * 0.2, -size, size * 0.2, -size * 0.7, size * 0.4, -size * 0.7, size * 0.4, size * 0.8, -size * 0.4, size * 0.8, -size * 0.4, -size * 0.7, -size * 0.2, -size * 0.7]), 4); }
        function createBookShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.8, -size * 0.6, size * 0.8, -size * 0.6, size * 0.8, size * 0.6, -size * 0.8, size * 0.6]), 3); }
        function createPhoneShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.4, -size, size * 0.4, -size, size * 0.4, size, -size * 0.4, size]), 8); }
        function createLaptopShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.9, size * 0.2, // Bottom left (wider)
                size * 0.9, size * 0.2, // Bottom right (wider)
                size * 0.5, -size * 0.8, // Top right (screen)
                -size * 0.5, -size * 0.8 // Top left (screen)
            ]);
            return new RoundedPolygon(vertices, 4);
        }
        function createCameraShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.8, -size * 0.2, size * 0.8, -size * 0.2, size * 0.8, size * 0.6, -size * 0.8, size * 0.6]), 3); }

        function createPuzzlePieceShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                // Main square outline with one corner cut out
                -size * 0.8, -size * 0.8, // Top left
                size * 0.8, -size * 0.8, // Top right
                size * 0.8, 0, // Right middle
                0, 0, // Center (cut corner start)
                0, size * 0.8, // Bottom middle
                -size * 0.8, size * 0.8, // Bottom left
                -size * 0.8, -size * 0.8 // Back to start
            ]);
            return new RoundedPolygon(vertices, 4);
        }


        function createAnchorShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([0, -size, size * 0.2, -size * 0.6, size * 0.2, 0, size * 0.6, size * 0.4, size * 0.8, size * 0.8, size * 0.4, size * 0.6, size * 0.2, size * 0.2, -size * 0.2, size * 0.2, -size * 0.4, size * 0.6, -size * 0.8, size * 0.8, -size * 0.6, size * 0.4, -size * 0.2, 0, -size * 0.2, -size * 0.6]), 3); }
        function createCrownShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.8, size * 0.2, -size * 0.6, -size * 0.4, -size * 0.3, size * 0.2, 0, -size * 0.8, size * 0.3, size * 0.2, size * 0.6, -size * 0.4, size * 0.8, size * 0.2, size * 0.8, size * 0.6, -size * 0.8, size * 0.6]), 4); }

        function createFallbackShape(index, RoundedPolygon) {
            switch (index) {
                case 0: return new RoundedPolygon(new Float32Array([0, -20, 17, 10, -17, 10]), 6);
                case 1: return new RoundedPolygon(new Float32Array([-15, -15, 15, -15, 15, 15, -15, 15]), 8);
                case 2: return new RoundedPolygon(new Float32Array([0, -17, 16, -5, 10, 14, -10, 14, -16, -5]), 5);
                case 3: return createStarPolygon(15, 5, RoundedPolygon);
                case 4: return new RoundedPolygon(new Float32Array([20, 0, 10, 17, -10, 17, -20, 0, -10, -17, 10, -17]), 4);
                case 5: return createCirclePolygon(15, 8, RoundedPolygon);
                case 6: return createStarPolygon(18, 6, RoundedPolygon);
                case 7: return createDiamondShape(18, RoundedPolygon);
                case 8: return createCrossShape(16, RoundedPolygon);
                case 9: return createArrowShape(18, RoundedPolygon);
                case 10: return createStarPolygon(14, 4, RoundedPolygon);
                case 11: return createOvalShape(18, 12, RoundedPolygon);
                case 12: return createTearDropShape(16, RoundedPolygon);
                case 13: return createMoonShape(16, RoundedPolygon);
                case 14: return createFlowerShape(15, RoundedPolygon);
                case 15: return createHouseShape(16, RoundedPolygon);
                case 16: return createSpadeShape(16, RoundedPolygon);
                case 17: return createInfinityShape(18, RoundedPolygon);
                case 18: return createGearShape(16, RoundedPolygon);
                case 19: return createSunShape(17, RoundedPolygon);
                case 20: return createBoltShape(18, RoundedPolygon);
                case 21: return createWaveShape(20, RoundedPolygon);
                case 22: return createRingShape(16, RoundedPolygon); // Fixed ring
                case 23: return createPillShape(18, RoundedPolygon);
                case 24: return createBoneShape(18, RoundedPolygon);
                case 25: return createMountainShape(18, RoundedPolygon);
                case 26: return createFishShape(18, RoundedPolygon);
                case 27: return createTreeShape(17, RoundedPolygon);
                case 28: return createCactusShape(15, RoundedPolygon);
                case 29: return createCupShape(15, RoundedPolygon); // Wide bottom cup
                case 30: return createBottleShape(14, RoundedPolygon);
                case 31: return createBookShape(16, RoundedPolygon);
                case 32: return createPhoneShape(14, RoundedPolygon);
                case 33: return createLaptopShape(18, RoundedPolygon); // Wide bottom laptop
                case 34: return createCameraShape(16, RoundedPolygon);
                case 35: return createPuzzlePieceShape(16, RoundedPolygon); // Simple puzzle piece
                case 36: return createAnchorShape(16, RoundedPolygon);
                case 37: return createCrownShape(17, RoundedPolygon);
                case 38: return createStarPolygon(12, 8, RoundedPolygon); // 8-pointed Star
                default: return createCirclePolygon(15, 8, RoundedPolygon);
            }
        }

        function drawShape(canvas, roundedPolygon) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Set colors based on theme
            const fillColor = currentTheme === 'dark' ? '#D9E2FF' : '#324574';

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(1.5, 1.5); // Scale up for better visibility

            if (roundedPolygon && roundedPolygon.cubics) {
                drawCubics(roundedPolygon.cubics, fillColor, ctx);
            }

            ctx.restore();
        }

        function drawCubics(cubics, color, ctx) {
            if (!cubics || cubics.length === 0) return;

            ctx.fillStyle = color;
            ctx.beginPath();

            const firstCubic = cubics[0];
            ctx.moveTo(firstCubic.anchor0X, firstCubic.anchor0Y);

            for (const cubic of cubics) {
                ctx.bezierCurveTo(
                    cubic.control0X, cubic.control0Y,
                    cubic.control1X, cubic.control1Y,
                    cubic.anchor1X, cubic.anchor1Y
                );
            }

            ctx.closePath();
            ctx.fill();
        }

        function renderShapes() {
            const grid = document.getElementById('shapesGrid');
            grid.innerHTML = '';
            
            shapeDefinitions.forEach(shape => {
                const card = document.createElement('div');
                card.className = 'shape-card';
                
                const canvas = document.createElement('canvas');
                canvas.className = 'shape-canvas';
                canvas.width = 80;
                canvas.height = 80;
                
                const name = document.createElement('div');
                name.className = 'shape-name';
                name.textContent = shape.name;
                
                const index = document.createElement('div');
                index.className = 'shape-index';
                index.textContent = `#${shape.index}`;
                
                card.appendChild(index);
                card.appendChild(canvas);
                card.appendChild(name);
                grid.appendChild(card);
                
                // Create and draw the actual rounded shape
                const roundedPolygon = createFallbackShape(shape.index, RoundedPolygon);
                drawShape(canvas, roundedPolygon);
            });
        }

        // Initial render
        renderShapes();
    </script>
</body>
</html>
