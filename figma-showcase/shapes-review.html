<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoadingIndicator Shapes Review</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 40px;
            font-size: 1.2em;
        }
        
        .shapes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .shape-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .shape-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border-color: #667eea;
        }
        
        .shape-canvas {
            width: 80px;
            height: 80px;
            margin: 0 auto 15px;
            border-radius: 8px;
            background: #fff;
            border: 1px solid #dee2e6;
        }
        
        .shape-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        
        .shape-index {
            color: #6c757d;
            font-size: 0.9em;
            position: absolute;
            top: 10px;
            right: 15px;
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 500;
        }
        
        .instructions {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .instructions h3 {
            margin-top: 0;
            color: #1976d2;
        }
        
        .theme-toggle {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .theme-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            margin: 0 10px;
            transition: all 0.3s ease;
        }
        
        .theme-btn:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }
        
        .theme-btn.active {
            background: #4caf50;
        }
        
        .dark-theme {
            background: #2c3e50;
        }
        
        .dark-theme .container {
            background: #34495e;
            color: #ecf0f1;
        }
        
        .dark-theme .shape-card {
            background: #3c5470;
            border-color: #4a6584;
        }
        
        .dark-theme .shape-canvas {
            background: #2c3e50;
            border-color: #4a6584;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® LoadingIndicator Shapes Review</h1>
        <p class="subtitle">All 63 shapes from the enhanced loading indicator</p>
        
        <div class="instructions">
            <h3>üìã Review Instructions</h3>
            <p>Each shape is rendered exactly as it appears in the LoadingIndicator component. Review each one and let me know which shapes to:</p>
            <ul>
                <li><strong>Keep</strong> - Shape looks good as-is</li>
                <li><strong>Modify</strong> - Shape needs adjustments (specify what changes)</li>
                <li><strong>Delete</strong> - Shape should be removed from the collection</li>
            </ul>
        </div>
        
        <div class="theme-toggle">
            <button class="theme-btn active" onclick="setTheme('light')">‚òÄÔ∏è Light Theme</button>
            <button class="theme-btn" onclick="setTheme('dark')">üåô Dark Theme</button>
        </div>
        
        <div class="shapes-grid" id="shapesGrid">
            <!-- Shapes will be dynamically generated here -->
        </div>
    </div>

    <script type="module">
        // Import the actual LoadingIndicator modules
        import { Point } from '../src/components/common/LoadingIndicator/utils.js';
        import { Cubic } from '../src/components/common/LoadingIndicator/cubic.js';
        import { RoundedPolygon } from '../src/components/common/LoadingIndicator/roundedPolygon.js';

        // New collection based on Material Design shapes
        const shapeDefinitions = [
            { name: "Circle", index: 0 },
            { name: "Square", index: 1 },
            { name: "Slanted", index: 2 },
            { name: "Arch", index: 3 },
            { name: "Semicircle", index: 4 },
            { name: "Oval", index: 5 },
            { name: "Pill", index: 6 },
            { name: "Triangle", index: 7 },
            { name: "Arrow", index: 8 },
            { name: "Fan", index: 9 },
            { name: "Diamond", index: 10 },
            { name: "Clamshell", index: 11 },
            { name: "Pentagon", index: 12 },
            { name: "Gem", index: 13 },
            { name: "Sunny", index: 14 },
            { name: "Very Sunny", index: 15 },
            { name: "4-sided Cookie", index: 16 },
            { name: "6-sided Cookie", index: 17 },
            { name: "7-sided Cookie", index: 18 },
            { name: "9-sided Cookie", index: 19 },
            { name: "12-sided Cookie", index: 20 },
            { name: "4-leaf Clover", index: 21 },
            { name: "8-leaf Clover", index: 22 },
            { name: "Burst", index: 23 },
            { name: "Soft Burst", index: 24 },
            { name: "Boom", index: 25 },
            { name: "Soft Boom", index: 26 },
            { name: "Flower", index: 27 },
            { name: "Puffy", index: 28 },
            { name: "Puffy Diamond", index: 29 },
            { name: "Ghost-ish", index: 30 },
            { name: "Pixel Circle", index: 31 },
            { name: "Pixel Triangle", index: 32 },
            { name: "Bun", index: 33 },
            { name: "Heart", index: 34 },
            { name: "Crescent Moon", index: 35 },
            { name: "Spade", index: 36 },
            { name: "Infinity", index: 37 },
            { name: "Gear", index: 38 },
            { name: "Snowflake", index: 39 },
            { name: "Bolt", index: 40 },
            { name: "Wave", index: 41 },
            { name: "Bone", index: 42 },
            { name: "Mountain", index: 43 },
            { name: "Fish", index: 44 },
            { name: "Tree", index: 45 },
            { name: "Cactus", index: 46 },
            { name: "Cup", index: 47 },
            { name: "Bottle", index: 48 },
            { name: "Book", index: 49 },
            { name: "Phone", index: 50 },
            { name: "Laptop", index: 51 },
            { name: "Camera", index: 52 },
            { name: "Puzzle Piece", index: 53 },
            { name: "Anchor", index: 54 },
            { name: "Crown", index: 55 },
            { name: "House", index: 56 },
            { name: "Cross/Plus", index: 57 },
            { name: "4-pointed Star", index: 58 },
            { name: "5-pointed Star", index: 59 },
            { name: "6-pointed Star", index: 60 },
            { name: "Hexagon", index: 61 },
            { name: "Octagon", index: 62 }
        ];

        let currentTheme = 'light';

        // Define setTheme function in global scope
        window.setTheme = function(theme) {
            currentTheme = theme;
            document.body.className = theme === 'dark' ? 'dark-theme' : '';
            
            // Update button states
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Re-render shapes with new theme
            renderShapes();
        };

        // Actual shape creation functions from LoadingIndicator.js
        function createCirclePolygon(radius, sides, RoundedPolygon) {
            const vertices = new Float32Array(sides * 2);
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI;
                vertices[i * 2] = Math.cos(angle) * radius;
                vertices[i * 2 + 1] = Math.sin(angle) * radius;
            }
            return new RoundedPolygon(vertices, 3);
        }

        function createStarPolygon(radius, points, RoundedPolygon) {
            const vertices = new Float32Array(points * 4);
            const innerRadius = radius * 0.4;
            let vertexIndex = 0;

            for (let i = 0; i < points; i++) {
                const outerAngle = (i / points) * 2 * Math.PI - Math.PI / 2;
                vertices[vertexIndex++] = Math.cos(outerAngle) * radius;
                vertices[vertexIndex++] = Math.sin(outerAngle) * radius;

                const innerAngle = ((i + 0.5) / points) * 2 * Math.PI - Math.PI / 2;
                vertices[vertexIndex++] = Math.cos(innerAngle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(innerAngle) * innerRadius;
            }
            return new RoundedPolygon(vertices, 2);
        }

        // All the additional shape creation functions from LoadingIndicator
        function createDiamondShape(size, RoundedPolygon) {
            const vertices = new Float32Array([0, -size, size, 0, 0, size, -size, 0]);
            return new RoundedPolygon(vertices, 4);
        }

        function createCrossShape(size, RoundedPolygon) {
            const thickness = size * 0.3;
            const vertices = new Float32Array([
                -thickness, -size, thickness, -size, thickness, -thickness,
                size, -thickness, size, thickness, thickness, thickness,
                thickness, size, -thickness, size, -thickness, thickness,
                -size, thickness, -size, -thickness, -thickness, -thickness
            ]);
            return new RoundedPolygon(vertices, 3);
        }

        function createArrowShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                0, -size, size * 0.5, -size * 0.3, size * 0.2, -size * 0.3,
                size * 0.2, size, -size * 0.2, size, -size * 0.2, -size * 0.3,
                -size * 0.5, -size * 0.3
            ]);
            return new RoundedPolygon(vertices, 3);
        }

        function createOvalShape(width, height, RoundedPolygon) {
            const sides = 24; // More sides for smoother oval
            const vertices = new Float32Array(sides * 2);
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI;
                vertices[i * 2] = Math.cos(angle) * width;
                vertices[i * 2 + 1] = Math.sin(angle) * height;
            }
            return new RoundedPolygon(vertices, 1); // Less rounding for smoother curves
        }

        function createTearDropShape(size, RoundedPolygon) {
            // Realistic teardrop shape with smooth curves
            const vertices = new Float32Array([
                0, -size, // Sharp point at top
                size * 0.5, -size * 0.6, // Right side curve
                size * 0.8, -size * 0.1, // Right bulge
                size * 0.9, size * 0.3, // Right bottom
                size * 0.6, size * 0.7, // Right bottom curve
                size * 0.2, size * 0.9, // Bottom right
                0, size, // Bottom center
                -size * 0.2, size * 0.9, // Bottom left
                -size * 0.6, size * 0.7, // Left bottom curve
                -size * 0.9, size * 0.3, // Left bottom
                -size * 0.8, -size * 0.1, // Left bulge
                -size * 0.5, -size * 0.6 // Left side curve
            ]);
            return new RoundedPolygon(vertices, 6); // Higher rounding for smooth teardrop
        }

        // Add the remaining shape creation functions
        function createMoonShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                size * 0.5, -size * 0.8, size * 0.8, -size * 0.3, size * 0.6, 0,
                size * 0.8, size * 0.3, size * 0.5, size * 0.8, 0, size * 0.5,
                -size * 0.3, size * 0.2, -size * 0.5, 0, -size * 0.3, -size * 0.2,
                0, -size * 0.5
            ]);
            return new RoundedPolygon(vertices, 5);
        }

        function createFlowerShape(size, RoundedPolygon) {
            const petals = 8;
            const vertices = new Float32Array(petals * 4);
            let vertexIndex = 0;

            for (let i = 0; i < petals; i++) {
                const angle = (i / petals) * 2 * Math.PI;
                const petalTipX = Math.cos(angle) * size;
                const petalTipY = Math.sin(angle) * size;
                const petalBaseX = Math.cos(angle) * size * 0.3;
                const petalBaseY = Math.sin(angle) * size * 0.3;

                vertices[vertexIndex++] = petalTipX;
                vertices[vertexIndex++] = petalTipY;
                vertices[vertexIndex++] = petalBaseX;
                vertices[vertexIndex++] = petalBaseY;
            }
            return new RoundedPolygon(vertices, 6);
        }

        function createHouseShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                0, -size, size * 0.7, -size * 0.3, size * 0.7, size * 0.2,
                size * 0.7, size * 0.8, -size * 0.7, size * 0.8, -size * 0.7, size * 0.2,
                -size * 0.7, -size * 0.3
            ]);
            return new RoundedPolygon(vertices, 5);
        }

        function createSpadeShape(size, RoundedPolygon) {
            // Smooth spade card suit
            const vertices = new Float32Array([
                0, -size, // Top point
                size * 0.4, -size * 0.6, // Right top curve
                size * 0.7, -size * 0.2, // Right side
                size * 0.8, size * 0.1, // Right bulge
                size * 0.6, size * 0.4, // Right bottom curve
                size * 0.3, size * 0.5, // Right stem connection
                size * 0.25, size * 0.7, // Right stem
                size * 0.15, size * 0.9, // Right stem bottom
                0, size, // Bottom center
                -size * 0.15, size * 0.9, // Left stem bottom
                -size * 0.25, size * 0.7, // Left stem
                -size * 0.3, size * 0.5, // Left stem connection
                -size * 0.6, size * 0.4, // Left bottom curve
                -size * 0.8, size * 0.1, // Left bulge
                -size * 0.7, -size * 0.2, // Left side
                -size * 0.4, -size * 0.6 // Left top curve
            ]);
            return new RoundedPolygon(vertices, 5); // Higher rounding for smooth curves
        }

        function createInfinityShape(size, RoundedPolygon) {
            // Smooth infinity symbol (figure-8) with more natural curves
            const vertices = new Float32Array([
                -size * 0.9, 0, // Left outer point
                -size * 0.7, -size * 0.3, // Left top curve
                -size * 0.4, -size * 0.4, // Left top inner
                -size * 0.1, -size * 0.3, // Center top left
                0, 0, // Center crossing
                size * 0.1, -size * 0.3, // Center top right
                size * 0.4, -size * 0.4, // Right top inner
                size * 0.7, -size * 0.3, // Right top curve
                size * 0.9, 0, // Right outer point
                size * 0.7, size * 0.3, // Right bottom curve
                size * 0.4, size * 0.4, // Right bottom inner
                size * 0.1, size * 0.3, // Center bottom right
                0, 0, // Center crossing (duplicate for smooth path)
                -size * 0.1, size * 0.3, // Center bottom left
                -size * 0.4, size * 0.4, // Left bottom inner
                -size * 0.7, size * 0.3 // Left bottom curve
            ]);
            return new RoundedPolygon(vertices, 8); // High rounding for smooth infinity curves
        }

        function createGearShape(size, RoundedPolygon) {
            const teeth = 8;
            const innerRadius = size * 0.6;
            const outerRadius = size;
            const vertices = new Float32Array(teeth * 4);
            let vertexIndex = 0;

            for (let i = 0; i < teeth; i++) {
                const baseAngle = (i / teeth) * 2 * Math.PI;
                const toothAngle = ((i + 0.5) / teeth) * 2 * Math.PI;

                vertices[vertexIndex++] = Math.cos(baseAngle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(baseAngle) * innerRadius;

                vertices[vertexIndex++] = Math.cos(toothAngle) * outerRadius;
                vertices[vertexIndex++] = Math.sin(toothAngle) * outerRadius;
            }
            return new RoundedPolygon(vertices, 2);
        }

        // Add all the new shape functions
        function createSunShape(size, RoundedPolygon) {
            const rays = 12;
            const innerRadius = size * 0.5;
            const outerRadius = size;
            const vertices = new Float32Array(rays * 4);
            let vertexIndex = 0;

            for (let i = 0; i < rays; i++) {
                const baseAngle = (i / rays) * 2 * Math.PI;
                const rayAngle = ((i + 0.5) / rays) * 2 * Math.PI;

                vertices[vertexIndex++] = Math.cos(baseAngle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(baseAngle) * innerRadius;

                vertices[vertexIndex++] = Math.cos(rayAngle) * outerRadius;
                vertices[vertexIndex++] = Math.sin(rayAngle) * outerRadius;
            }
            return new RoundedPolygon(vertices, 4);
        }

        function createSnowflakeShape(size, RoundedPolygon) {
            const arms = 6;
            const vertices = new Float32Array(arms * 8);
            let vertexIndex = 0;

            for (let i = 0; i < arms; i++) {
                const angle = (i / arms) * 2 * Math.PI;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);

                // Main arm
                vertices[vertexIndex++] = 0;
                vertices[vertexIndex++] = 0;
                vertices[vertexIndex++] = cos * size * 0.4;
                vertices[vertexIndex++] = sin * size * 0.4;
                vertices[vertexIndex++] = cos * size * 1.2; // Made bigger
                vertices[vertexIndex++] = sin * size * 1.2; // Made bigger

                // Side branches for more snowflake detail
                vertices[vertexIndex++] = cos * size * 0.8 + Math.cos(angle + Math.PI/6) * size * 0.3;
                vertices[vertexIndex++] = sin * size * 0.8 + Math.sin(angle + Math.PI/6) * size * 0.3;
            }
            return new RoundedPolygon(vertices, 2);
        }

        function createBoltShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                0, -size, size * 0.3, -size * 0.7, size * 0.2, -size * 0.3,
                size * 0.4, -size * 0.1, size * 0.2, size * 0.1, size * 0.4, size * 0.3,
                size * 0.2, size * 0.5, size * 0.4, size * 0.7, size * 0.2, size,
                -size * 0.2, size, -size * 0.4, size * 0.7, -size * 0.2, size * 0.5,
                -size * 0.4, size * 0.3, -size * 0.2, size * 0.1, -size * 0.4, -size * 0.1,
                -size * 0.2, -size * 0.3, -size * 0.3, -size * 0.7
            ]);
            return new RoundedPolygon(vertices, 2);
        }

        // New shape creation functions for the updated collection
        function createSlantedShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size, -size * 0.7, size, -size, size, size * 0.7, -size, size]);
            return new RoundedPolygon(vertices, 8);
        }

        function createArchShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size, size, -size, 0, -size * 0.7, -size * 0.7, 0, -size,
                size * 0.7, -size * 0.7, size, 0, size, size
            ]);
            return new RoundedPolygon(vertices, 6);
        }

        function createSemicircleShape(size, RoundedPolygon) {
            const sides = 12;
            const vertices = new Float32Array((sides + 1) * 2);
            let vertexIndex = 0;

            for (let i = 0; i <= sides; i++) {
                const angle = (i / sides) * Math.PI;
                vertices[vertexIndex++] = Math.cos(angle) * size;
                vertices[vertexIndex++] = Math.sin(angle) * size;
            }
            return new RoundedPolygon(vertices, 4);
        }

        function createFanShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                0, 0, -size * 0.8, -size * 0.6, -size, 0, -size * 0.8, size * 0.6,
                -size * 0.3, size * 0.9, size * 0.3, size * 0.9, size * 0.8, size * 0.6,
                size, 0, size * 0.8, -size * 0.6
            ]);
            return new RoundedPolygon(vertices, 5);
        }

        function createClamshellShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.8, size * 0.3, -size * 0.9, 0, -size * 0.7, -size * 0.5,
                -size * 0.3, -size * 0.8, 0, -size * 0.9, size * 0.3, -size * 0.8,
                size * 0.7, -size * 0.5, size * 0.9, 0, size * 0.8, size * 0.3,
                size * 0.5, size * 0.6, 0, size * 0.8, -size * 0.5, size * 0.6
            ]);
            return new RoundedPolygon(vertices, 6);
        }

        function createGemShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                0, -size, size * 0.6, -size * 0.4, size * 0.8, size * 0.2,
                size * 0.4, size * 0.8, -size * 0.4, size * 0.8, -size * 0.8, size * 0.2,
                -size * 0.6, -size * 0.4
            ]);
            return new RoundedPolygon(vertices, 4);
        }

        function createSunnyShape(size, RoundedPolygon) {
            const points = 8;
            const vertices = new Float32Array(points * 4);
            let vertexIndex = 0;

            for (let i = 0; i < points; i++) {
                const angle = (i / points) * 2 * Math.PI;
                const innerRadius = size * 0.6;
                const outerRadius = size * 0.9;

                vertices[vertexIndex++] = Math.cos(angle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(angle) * innerRadius;
                vertices[vertexIndex++] = Math.cos(angle + Math.PI / points) * outerRadius;
                vertices[vertexIndex++] = Math.sin(angle + Math.PI / points) * outerRadius;
            }
            return new RoundedPolygon(vertices, 5);
        }

        function createVerySunnyShape(size, RoundedPolygon) {
            const points = 12;
            const vertices = new Float32Array(points * 4);
            let vertexIndex = 0;

            for (let i = 0; i < points; i++) {
                const angle = (i / points) * 2 * Math.PI;
                const innerRadius = size * 0.5;
                const outerRadius = size;

                vertices[vertexIndex++] = Math.cos(angle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(angle) * innerRadius;
                vertices[vertexIndex++] = Math.cos(angle + Math.PI / points) * outerRadius;
                vertices[vertexIndex++] = Math.sin(angle + Math.PI / points) * outerRadius;
            }
            return new RoundedPolygon(vertices, 3);
        }

        function createCookieShape(size, sides, RoundedPolygon) {
            const vertices = new Float32Array(sides * 4);
            let vertexIndex = 0;

            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI;
                const innerRadius = size * 0.7;
                const outerRadius = size;

                vertices[vertexIndex++] = Math.cos(angle) * outerRadius;
                vertices[vertexIndex++] = Math.sin(angle) * outerRadius;
                vertices[vertexIndex++] = Math.cos(angle + Math.PI / sides) * innerRadius;
                vertices[vertexIndex++] = Math.sin(angle + Math.PI / sides) * innerRadius;
            }
            return new RoundedPolygon(vertices, 6);
        }

        function createCloverShape(size, leaves, RoundedPolygon) {
            const vertices = new Float32Array(leaves * 6);
            let vertexIndex = 0;

            for (let i = 0; i < leaves; i++) {
                const angle = (i / leaves) * 2 * Math.PI;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);

                vertices[vertexIndex++] = 0;
                vertices[vertexIndex++] = 0;
                vertices[vertexIndex++] = cos * size * 0.5;
                vertices[vertexIndex++] = sin * size * 0.5;
                vertices[vertexIndex++] = cos * size;
                vertices[vertexIndex++] = sin * size;
            }
            return new RoundedPolygon(vertices, 8);
        }

        function createBurstShape(size, RoundedPolygon) {
            const spikes = 8;
            const vertices = new Float32Array(spikes * 2);
            let vertexIndex = 0;

            for (let i = 0; i < spikes; i++) {
                const angle = (i / spikes) * 2 * Math.PI;
                const radius = i % 2 === 0 ? size : size * 0.3;
                vertices[vertexIndex++] = Math.cos(angle) * radius;
                vertices[vertexIndex++] = Math.sin(angle) * radius;
            }
            return new RoundedPolygon(vertices, 2);
        }

        function createSoftBurstShape(size, RoundedPolygon) {
            const spikes = 8;
            const vertices = new Float32Array(spikes * 2);
            let vertexIndex = 0;

            for (let i = 0; i < spikes; i++) {
                const angle = (i / spikes) * 2 * Math.PI;
                const radius = i % 2 === 0 ? size : size * 0.6;
                vertices[vertexIndex++] = Math.cos(angle) * radius;
                vertices[vertexIndex++] = Math.sin(angle) * radius;
            }
            return new RoundedPolygon(vertices, 6);
        }

        function createBoomShape(size, RoundedPolygon) {
            const rays = 16;
            const vertices = new Float32Array(rays * 2);
            let vertexIndex = 0;

            for (let i = 0; i < rays; i++) {
                const angle = (i / rays) * 2 * Math.PI;
                const radius = i % 2 === 0 ? size : size * 0.2;
                vertices[vertexIndex++] = Math.cos(angle) * radius;
                vertices[vertexIndex++] = Math.sin(angle) * radius;
            }
            return new RoundedPolygon(vertices, 1);
        }

        function createSoftBoomShape(size, RoundedPolygon) {
            const rays = 16;
            const vertices = new Float32Array(rays * 2);
            let vertexIndex = 0;

            for (let i = 0; i < rays; i++) {
                const angle = (i / rays) * 2 * Math.PI;
                const radius = i % 2 === 0 ? size : size * 0.4;
                vertices[vertexIndex++] = Math.cos(angle) * radius;
                vertices[vertexIndex++] = Math.sin(angle) * radius;
            }
            return new RoundedPolygon(vertices, 4);
        }

        function createPuffyShape(size, RoundedPolygon) {
            const bumps = 12;
            const vertices = new Float32Array(bumps * 2);
            let vertexIndex = 0;

            for (let i = 0; i < bumps; i++) {
                const angle = (i / bumps) * 2 * Math.PI;
                const radius = size * (0.7 + 0.3 * Math.sin(i * 3));
                vertices[vertexIndex++] = Math.cos(angle) * radius;
                vertices[vertexIndex++] = Math.sin(angle) * radius;
            }
            return new RoundedPolygon(vertices, 8);
        }

        function createPuffyDiamondShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                0, -size * 1.1, size * 0.7, -size * 0.3, size * 1.1, 0,
                size * 0.7, size * 0.3, 0, size * 1.1, -size * 0.7, size * 0.3,
                -size * 1.1, 0, -size * 0.7, -size * 0.3
            ]);
            return new RoundedPolygon(vertices, 8);
        }

        function createGhostishShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.7, -size * 0.8, size * 0.7, -size * 0.8, size * 0.8, -size * 0.3,
                size * 0.8, size * 0.5, size * 0.6, size * 0.8, size * 0.4, size * 0.6,
                size * 0.2, size * 0.8, 0, size * 0.6, -size * 0.2, size * 0.8,
                -size * 0.4, size * 0.6, -size * 0.6, size * 0.8, -size * 0.8, size * 0.5,
                -size * 0.8, -size * 0.3
            ]);
            return new RoundedPolygon(vertices, 6);
        }

        function createPixelCircleShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.8, -size * 0.4, -size * 0.4, -size * 0.8, size * 0.4, -size * 0.8,
                size * 0.8, -size * 0.4, size * 0.8, size * 0.4, size * 0.4, size * 0.8,
                -size * 0.4, size * 0.8, -size * 0.8, size * 0.4
            ]);
            return new RoundedPolygon(vertices, 2);
        }

        function createPixelTriangleShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.2, -size * 0.8, size * 0.2, -size * 0.8, size * 0.6, -size * 0.4,
                size * 0.8, 0, size * 0.6, size * 0.4, size * 0.2, size * 0.8,
                -size * 0.2, size * 0.8, -size * 0.6, size * 0.4, -size * 0.8, 0,
                -size * 0.6, -size * 0.4
            ]);
            return new RoundedPolygon(vertices, 2);
        }

        function createBunShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.8, size * 0.2, -size * 0.9, -size * 0.2, -size * 0.6, -size * 0.7,
                -size * 0.2, -size * 0.8, size * 0.2, -size * 0.8, size * 0.6, -size * 0.7,
                size * 0.9, -size * 0.2, size * 0.8, size * 0.2, size * 0.6, size * 0.6,
                size * 0.2, size * 0.8, -size * 0.2, size * 0.8, -size * 0.6, size * 0.6
            ]);
            return new RoundedPolygon(vertices, 8);
        }

        function createHeartShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                0, size * 0.8, -size * 0.4, size * 0.4, -size * 0.7, 0,
                -size * 0.8, -size * 0.3, -size * 0.6, -size * 0.6, -size * 0.3, -size * 0.7,
                0, -size * 0.5, size * 0.3, -size * 0.7, size * 0.6, -size * 0.6,
                size * 0.8, -size * 0.3, size * 0.7, 0, size * 0.4, size * 0.4
            ]);
            return new RoundedPolygon(vertices, 6);
        }

        function createWaveShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size, 0, -size * 0.7, -size * 0.5, -size * 0.3, -size * 0.3, 0, -size * 0.6, size * 0.3, -size * 0.3, size * 0.7, -size * 0.5, size, 0, size * 0.7, size * 0.5, size * 0.3, size * 0.3, 0, size * 0.6, -size * 0.3, size * 0.3, -size * 0.7, size * 0.5]);
            return new RoundedPolygon(vertices, 7);
        }
        function createRingShape(size, RoundedPolygon) {
            const outerSides = 20;
            const innerRadius = size * 0.5;
            const vertices = new Float32Array(outerSides * 4);
            let vertexIndex = 0;

            for (let i = 0; i < outerSides; i++) {
                const angle = (i / outerSides) * 2 * Math.PI;
                // Outer circle
                vertices[vertexIndex++] = Math.cos(angle) * size;
                vertices[vertexIndex++] = Math.sin(angle) * size;
                // Inner circle
                vertices[vertexIndex++] = Math.cos(angle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(angle) * innerRadius;
            }
            return new RoundedPolygon(vertices, 4);
        }
        function createPillShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size * 0.5, -size, size * 0.5, -size, size, -size * 0.5, size, size * 0.5, size * 0.5, size, -size * 0.5, size, -size, size * 0.5, -size, -size * 0.5]);
            return new RoundedPolygon(vertices, 8);
        }
        function createBoneShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size * 0.8, -size * 0.3, -size * 0.6, -size * 0.6, -size * 0.3, -size * 0.4, -size * 0.1, -size * 0.2, size * 0.1, -size * 0.2, size * 0.3, -size * 0.4, size * 0.6, -size * 0.6, size * 0.8, -size * 0.3, size * 0.8, size * 0.3, size * 0.6, size * 0.6, size * 0.3, size * 0.4, size * 0.1, size * 0.2, -size * 0.1, size * 0.2, -size * 0.3, size * 0.4, -size * 0.6, size * 0.6, -size * 0.8, size * 0.3]);
            return new RoundedPolygon(vertices, 4);
        }
        function createCloudShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.8, size * 0.3, // Left edge
                -size * 0.9, -size * 0.1, // Left top
                -size * 0.6, -size * 0.5, // Deep valley 1
                -size * 0.2, -size * 0.7, // Peak 1
                size * 0.1, -size * 0.8, // Deep valley 2
                size * 0.4, -size * 0.6, // Peak 2
                size * 0.7, -size * 0.5, // Deep valley 3
                size * 0.9, -size * 0.1, // Right top
                size * 0.8, size * 0.3, // Right edge
                size * 0.4, size * 0.5, // Right bottom
                0, size * 0.6, // Bottom center
                -size * 0.4, size * 0.5 // Left bottom
            ]);
            return new RoundedPolygon(vertices, 6);
        }
        function createMountainShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size, size, -size * 0.6, size * 0.2, -size * 0.3, -size * 0.8, 0, -size * 0.4, size * 0.3, -size, size * 0.6, size * 0.2, size, size]);
            return new RoundedPolygon(vertices, 3);
        }
        function createFishShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size, 0, -size * 0.7, -size * 0.3, -size * 0.4, -size * 0.2, size * 0.2, -size * 0.4, size * 0.8, -size * 0.2, size, 0, size * 0.8, size * 0.2, size * 0.2, size * 0.4, -size * 0.4, size * 0.2, -size * 0.7, size * 0.3]);
            return new RoundedPolygon(vertices, 4);
        }

        function createTreeShape(size, RoundedPolygon) {
            const vertices = new Float32Array([-size * 0.1, size, -size * 0.1, size * 0.3, -size * 0.6, size * 0.2, -size * 0.7, -size * 0.2, -size * 0.3, -size * 0.8, 0, -size, size * 0.3, -size * 0.8, size * 0.7, -size * 0.2, size * 0.6, size * 0.2, size * 0.1, size * 0.3, size * 0.1, size]);
            return new RoundedPolygon(vertices, 5);
        }

        // Add remaining simple shapes
        function createCactusShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.2, size, -size * 0.2, -size * 0.2, -size * 0.6, -size * 0.4, -size * 0.6, -size * 0.8, -size * 0.4, -size * 0.8, -size * 0.4, -size * 0.4, -size * 0.1, -size * 0.4, -size * 0.1, -size, size * 0.1, -size, size * 0.1, -size * 0.4, size * 0.4, -size * 0.4, size * 0.4, -size * 0.8, size * 0.6, -size * 0.8, size * 0.6, -size * 0.4, size * 0.2, -size * 0.2, size * 0.2, size]), 4); }
        function createUmbrellaShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.8, 0, // Left edge
                -size * 0.6, -size * 0.5, // Left curve
                -size * 0.3, -size * 0.7, // Left peak
                0, -size * 0.8, // Top center
                size * 0.3, -size * 0.7, // Right peak
                size * 0.6, -size * 0.5, // Right curve
                size * 0.8, 0, // Right edge
                0, 0, // Handle start
                0, size * 0.7, // Handle shaft
                size * 0.15, size * 0.8, // Handle curve
                size * 0.2, size * 0.9, // Handle tip
                size * 0.1, size * 0.95, // Handle end
                0, size * 0.9, // Back to shaft
                0, 0 // Back to center
            ]);
            return new RoundedPolygon(vertices, 5);
        }
        function createCupShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.4, -size, // Top left
                size * 0.4, -size, // Top right
                size * 0.8, size * 0.8, // Bottom right (wider)
                -size * 0.8, size * 0.8 // Bottom left (wider)
            ]);
            return new RoundedPolygon(vertices, 6);
        }
        function createBottleShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.2, -size, size * 0.2, -size, size * 0.2, -size * 0.7, size * 0.4, -size * 0.7, size * 0.4, size * 0.8, -size * 0.4, size * 0.8, -size * 0.4, -size * 0.7, -size * 0.2, -size * 0.7]), 4); }
        function createBookShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.8, -size * 0.6, size * 0.8, -size * 0.6, size * 0.8, size * 0.6, -size * 0.8, size * 0.6]), 3); }
        function createPhoneShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.4, -size, size * 0.4, -size, size * 0.4, size, -size * 0.4, size]), 8); }
        function createLaptopShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                -size * 0.9, size * 0.2, // Bottom left (wider)
                size * 0.9, size * 0.2, // Bottom right (wider)
                size * 0.5, -size * 0.8, // Top right (screen)
                -size * 0.5, -size * 0.8 // Top left (screen)
            ]);
            return new RoundedPolygon(vertices, 4);
        }
        function createCameraShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.8, -size * 0.2, size * 0.8, -size * 0.2, size * 0.8, size * 0.6, -size * 0.8, size * 0.6]), 3); }
        function createMusicNoteShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                // Note head (oval)
                -size * 0.3, size * 0.5, // Left of note head
                -size * 0.4, size * 0.3, // Top left of note head
                -size * 0.3, size * 0.1, // Top of note head
                -size * 0.1, size * 0.1, // Top right of note head
                0, size * 0.3, // Right of note head
                -size * 0.1, size * 0.5, // Bottom right of note head
                -size * 0.3, size * 0.5, // Back to left

                // Stem
                -size * 0.1, size * 0.2, // Stem start
                -size * 0.1, -size * 0.8, // Stem top
                0, -size * 0.8, // Stem top right
                0, size * 0.2, // Stem bottom right

                // Flag
                0, -size * 0.8, // Flag start
                size * 0.4, -size * 0.6, // Flag curve out
                size * 0.3, -size * 0.4, // Flag curve back
                0, -size * 0.5, // Flag attach point
                0, -size * 0.6, // Flag second curve start
                size * 0.3, -size * 0.4, // Flag second curve out
                size * 0.2, -size * 0.2, // Flag second curve back
                0, -size * 0.3 // Flag second attach
            ]);
            return new RoundedPolygon(vertices, 3);
        }
        function createPuzzlePieceShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                // Main square outline with one corner cut out
                -size * 0.8, -size * 0.8, // Top left
                size * 0.8, -size * 0.8, // Top right
                size * 0.8, 0, // Right middle
                0, 0, // Center (cut corner start)
                0, size * 0.8, // Bottom middle
                -size * 0.8, size * 0.8, // Bottom left
                -size * 0.8, -size * 0.8 // Back to start
            ]);
            return new RoundedPolygon(vertices, 4);
        }
        function createMagnetShape(size, RoundedPolygon) {
            const vertices = new Float32Array([
                // Left arm of U
                -size * 0.8, -size, // Top left outer
                -size * 0.4, -size, // Top left inner
                -size * 0.4, size * 0.6, // Bottom left inner
                -size * 0.8, size * 0.6, // Bottom left outer
                -size * 0.8, size * 0.8, // Left bottom tip

                // Bottom of U
                -size * 0.6, size * 0.8, // Left bottom inner
                -size * 0.2, size * 0.9, // Bottom curve left
                size * 0.2, size * 0.9, // Bottom curve right
                size * 0.6, size * 0.8, // Right bottom inner

                // Right arm of U
                size * 0.8, size * 0.8, // Right bottom tip
                size * 0.8, size * 0.6, // Bottom right outer
                size * 0.4, size * 0.6, // Bottom right inner
                size * 0.4, -size, // Top right inner
                size * 0.8, -size, // Top right outer
                size * 0.8, -size * 0.4, // Top right connection
                -size * 0.8, -size * 0.4 // Top left connection
            ]);
            return new RoundedPolygon(vertices, 4);
        }

        function createAnchorShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([0, -size, size * 0.2, -size * 0.6, size * 0.2, 0, size * 0.6, size * 0.4, size * 0.8, size * 0.8, size * 0.4, size * 0.6, size * 0.2, size * 0.2, -size * 0.2, size * 0.2, -size * 0.4, size * 0.6, -size * 0.8, size * 0.8, -size * 0.6, size * 0.4, -size * 0.2, 0, -size * 0.2, -size * 0.6]), 3); }
        function createCrownShape(size, RoundedPolygon) { return new RoundedPolygon(new Float32Array([-size * 0.8, size * 0.2, -size * 0.6, -size * 0.4, -size * 0.3, size * 0.2, 0, -size * 0.8, size * 0.3, size * 0.2, size * 0.6, -size * 0.4, size * 0.8, size * 0.2, size * 0.8, size * 0.6, -size * 0.8, size * 0.6]), 4); }

        function createFallbackShape(index, RoundedPolygon) {
            switch (index) {
                case 0: return createCirclePolygon(15, 20, RoundedPolygon); // Circle
                case 1: return new RoundedPolygon(new Float32Array([-15, -15, 15, -15, 15, 15, -15, 15]), 8); // Square
                case 2: return createSlantedShape(16, RoundedPolygon); // Slanted
                case 3: return createArchShape(16, RoundedPolygon); // Arch
                case 4: return createSemicircleShape(16, RoundedPolygon); // Semicircle
                case 5: return createOvalShape(18, 12, RoundedPolygon); // Oval
                case 6: return createPillShape(18, RoundedPolygon); // Pill
                case 7: return new RoundedPolygon(new Float32Array([0, -20, 17, 10, -17, 10]), 6); // Triangle
                case 8: return createArrowShape(18, RoundedPolygon); // Arrow
                case 9: return createFanShape(16, RoundedPolygon); // Fan
                case 10: return createDiamondShape(18, RoundedPolygon); // Diamond
                case 11: return createClamshellShape(16, RoundedPolygon); // Clamshell
                case 12: return new RoundedPolygon(new Float32Array([0, -17, 16, -5, 10, 14, -10, 14, -16, -5]), 5); // Pentagon
                case 13: return createGemShape(16, RoundedPolygon); // Gem
                case 14: return createSunnyShape(16, RoundedPolygon); // Sunny
                case 15: return createVerySunnyShape(16, RoundedPolygon); // Very sunny
                case 16: return createCookieShape(16, 4, RoundedPolygon); // 4-sided cookie
                case 17: return createCookieShape(16, 6, RoundedPolygon); // 6-sided cookie
                case 18: return createCookieShape(16, 7, RoundedPolygon); // 7-sided cookie
                case 19: return createCookieShape(16, 9, RoundedPolygon); // 9-sided cookie
                case 20: return createCookieShape(16, 12, RoundedPolygon); // 12-sided cookie
                case 21: return createCloverShape(16, 4, RoundedPolygon); // 4-leaf clover
                case 22: return createCloverShape(16, 8, RoundedPolygon); // 8-leaf clover
                case 23: return createBurstShape(16, RoundedPolygon); // Burst
                case 24: return createSoftBurstShape(16, RoundedPolygon); // Soft burst
                case 25: return createBoomShape(16, RoundedPolygon); // Boom
                case 26: return createSoftBoomShape(16, RoundedPolygon); // Soft boom
                case 27: return createFlowerShape(15, RoundedPolygon); // Flower
                case 28: return createPuffyShape(16, RoundedPolygon); // Puffy
                case 29: return createPuffyDiamondShape(16, RoundedPolygon); // Puffy diamond
                case 30: return createGhostishShape(16, RoundedPolygon); // Ghost-ish
                case 31: return createPixelCircleShape(16, RoundedPolygon); // Pixel circle
                case 32: return createPixelTriangleShape(16, RoundedPolygon); // Pixel triangle
                case 33: return createBunShape(16, RoundedPolygon); // Bun
                case 34: return createHeartShape(16, RoundedPolygon); // Heart
                case 35: return createMoonShape(16, RoundedPolygon); // Crescent Moon
                case 36: return createSpadeShape(16, RoundedPolygon); // Spade
                case 37: return createInfinityShape(18, RoundedPolygon); // Infinity
                case 38: return createGearShape(16, RoundedPolygon); // Gear
                case 39: return createSnowflakeShape(20, RoundedPolygon); // Snowflake
                case 40: return createBoltShape(18, RoundedPolygon); // Bolt
                case 41: return createWaveShape(20, RoundedPolygon); // Wave
                case 42: return createBoneShape(18, RoundedPolygon); // Bone
                case 43: return createMountainShape(18, RoundedPolygon); // Mountain
                case 44: return createFishShape(18, RoundedPolygon); // Fish
                case 45: return createTreeShape(17, RoundedPolygon); // Tree
                case 46: return createCactusShape(15, RoundedPolygon); // Cactus
                case 47: return createCupShape(15, RoundedPolygon); // Cup
                case 48: return createBottleShape(14, RoundedPolygon); // Bottle
                case 49: return createBookShape(16, RoundedPolygon); // Book
                case 50: return createPhoneShape(14, RoundedPolygon); // Phone
                case 51: return createLaptopShape(18, RoundedPolygon); // Laptop
                case 52: return createCameraShape(16, RoundedPolygon); // Camera
                case 53: return createPuzzlePieceShape(16, RoundedPolygon); // Puzzle Piece
                case 54: return createAnchorShape(16, RoundedPolygon); // Anchor
                case 55: return createCrownShape(17, RoundedPolygon); // Crown
                case 56: return createHouseShape(16, RoundedPolygon); // House
                case 57: return createCrossShape(16, RoundedPolygon); // Cross/Plus
                case 58: return createStarPolygon(14, 4, RoundedPolygon); // 4-pointed Star
                case 59: return createStarPolygon(15, 5, RoundedPolygon); // 5-pointed Star
                case 60: return createStarPolygon(18, 6, RoundedPolygon); // 6-pointed Star
                case 61: return new RoundedPolygon(new Float32Array([20, 0, 10, 17, -10, 17, -20, 0, -10, -17, 10, -17]), 4); // Hexagon
                case 62: return createCirclePolygon(15, 8, RoundedPolygon); // Octagon
                default: return createCirclePolygon(15, 20, RoundedPolygon);
            }
        }

        function drawShape(canvas, roundedPolygon) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Set colors based on theme
            const fillColor = currentTheme === 'dark' ? '#D9E2FF' : '#324574';

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(1.5, 1.5); // Scale up for better visibility

            if (roundedPolygon && roundedPolygon.cubics) {
                drawCubics(roundedPolygon.cubics, fillColor, ctx);
            }

            ctx.restore();
        }

        function drawCubics(cubics, color, ctx) {
            if (!cubics || cubics.length === 0) return;

            ctx.fillStyle = color;
            ctx.beginPath();

            const firstCubic = cubics[0];
            ctx.moveTo(firstCubic.anchor0X, firstCubic.anchor0Y);

            for (const cubic of cubics) {
                ctx.bezierCurveTo(
                    cubic.control0X, cubic.control0Y,
                    cubic.control1X, cubic.control1Y,
                    cubic.anchor1X, cubic.anchor1Y
                );
            }

            ctx.closePath();
            ctx.fill();
        }

        function renderShapes() {
            const grid = document.getElementById('shapesGrid');
            grid.innerHTML = '';
            
            shapeDefinitions.forEach(shape => {
                const card = document.createElement('div');
                card.className = 'shape-card';
                
                const canvas = document.createElement('canvas');
                canvas.className = 'shape-canvas';
                canvas.width = 80;
                canvas.height = 80;
                
                const name = document.createElement('div');
                name.className = 'shape-name';
                name.textContent = shape.name;
                
                const index = document.createElement('div');
                index.className = 'shape-index';
                index.textContent = `#${shape.index}`;
                
                card.appendChild(index);
                card.appendChild(canvas);
                card.appendChild(name);
                grid.appendChild(card);
                
                // Create and draw the actual rounded shape
                const roundedPolygon = createFallbackShape(shape.index, RoundedPolygon);
                drawShape(canvas, roundedPolygon);
            });
        }

        // Initial render
        renderShapes();
    </script>
</body>
</html>
