<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loading Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .loading-animation {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 300px;
            height: 300px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            position: relative;
        }
    </style>
</head>
<body>
    <div class="loading-animation" id="loadingAnimation">
        <!-- SVG shapes will be loaded here -->
    </div>



    <script type="module">
        // Import the working modules
        import { Point } from './utils.js';
        import { Cubic } from './cubic.js';

        // Try to import the problematic modules
        let RoundedPolygon, Morph;

        async function initializeModules() {
            try {
                const roundedPolygonModule = await import('./roundedPolygon.js');
                RoundedPolygon = roundedPolygonModule.RoundedPolygon;
                console.log('✅ RoundedPolygon imported successfully');
            } catch (error) {
                console.error('❌ RoundedPolygon import failed:', error);
            }

            try {
                const morphModule = await import('./morph-fixed.js');
                Morph = morphModule.Morph;
                console.log('✅ Morph imported successfully');
            } catch (error) {
                console.error('❌ Morph import failed:', error);
            }

            // Initialize and auto-start animation
            await loadSVGShapes();
            startAnimation();
        }

        // Real Shape Morphing Animation (WORKING)
        let currentStep = 1;
        let animationInterval = null;
        let isAnimating = false;
        let morphShapes = [];
        let morphCanvas, morphCtx;
        let currentMorph = null;
        let morphProgress = 0;

        // Material 3 Expressive effects
        let rotationAngle = 0;
        let pulseValue = 1;
        let animationTime = 0;
        let discreteSpinSpeed = 0;

        async function loadSVGShapes() {
            const container = document.getElementById('loadingAnimation');

            // Create canvas for real shape morphing
            morphCanvas = document.createElement('canvas');
            morphCanvas.width = 300;
            morphCanvas.height = 300;
            morphCanvas.style.width = '100%';
            morphCanvas.style.height = '100%';
            morphCanvas.style.borderRadius = '12px';
            container.appendChild(morphCanvas);
            morphCtx = morphCanvas.getContext('2d');

            // Load and create shapes from Figma SVG files
            const result = await createFigmaShapes();
            morphShapes = result.shapes;

            console.log(`✅ Created ${morphShapes.length} real Figma shapes for morphing`);
            drawCurrentShape();
        }

        async function createFigmaShapes() {
            // Load the actual SVG files from your Figma design
            const figmaShapeFiles = [
                'shapes/shape-step1.svg',
                'shapes/shape-step2.svg',
                'shapes/shape-step3.svg',
                'shapes/shape-step4.svg',
                'shapes/shape-step5.svg',
                'shapes/shape-step6.svg',
                'shapes/shape-step7.svg'
            ];

            const shapes = [];

            for (let i = 0; i < figmaShapeFiles.length; i++) {
                try {
                    // Load the SVG file and extract the path
                    const response = await fetch(figmaShapeFiles[i]);
                    const svgText = await response.text();

                    // Parse the SVG to extract the path data
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                    const pathElement = svgDoc.querySelector('path');

                    if (pathElement) {
                        const pathData = pathElement.getAttribute('d');
                        // Convert to RoundedPolygon for morphing
                        const vertices = await convertSVGPathToVertices(pathData, 40);
                        const polygon = new RoundedPolygon(vertices, 0);
                        shapes.push(polygon);
                    } else {
                        throw new Error('No path element found in SVG');
                    }
                } catch (error) {
                    // Fallback to simple shapes if Figma shapes fail
                    shapes.push(createFallbackShape(i));
                }
            }

            return { shapes };
        }

        async function convertSVGPathToVertices(pathData, scale = 1) {
            // Create a temporary SVG to parse the path
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100');
            svg.setAttribute('height', '100');
            svg.style.position = 'absolute';
            svg.style.visibility = 'hidden';

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            svg.appendChild(path);
            document.body.appendChild(svg);

            try {
                // Get the bounding box to properly center the shape
                const bbox = path.getBBox();
                const centerX = bbox.x + bbox.width / 2;
                const centerY = bbox.y + bbox.height / 2;
                const maxDimension = Math.max(bbox.width, bbox.height);

                // Get the path length and use intelligent sampling
                const pathLength = path.getTotalLength();

                // Use curvature-based adaptive sampling for better shape preservation
                const vertices = await samplePathWithCurvatureDetection(path, pathLength, centerX, centerY, maxDimension, scale);

                document.body.removeChild(svg);
                return vertices;
            } catch (error) {
                document.body.removeChild(svg);
                throw error;
            }
        }

        async function samplePathWithCurvatureDetection(path, pathLength, centerX, centerY, maxDimension, scale) {
            // For star-like shapes, we need to detect peaks and valleys specifically
            const highResSamples = 500; // Very high resolution for feature detection

            // First pass: high-resolution sampling to detect all features
            const points = [];
            for (let i = 0; i <= highResSamples; i++) {
                const t = i / highResSamples;
                const distance = t * pathLength;
                const point = path.getPointAtLength(distance);

                // Calculate distance from center (for peak/valley detection)
                const distFromCenter = Math.sqrt(
                    Math.pow(point.x - centerX, 2) + Math.pow(point.y - centerY, 2)
                );

                points.push({ t, point, distFromCenter, index: i });
            }

            // Second pass: detect peaks and valleys based on distance from center
            const features = [];
            const windowSize = 8; // Smaller window for more sensitive detection

            for (let i = windowSize; i < points.length - windowSize; i++) {
                const current = points[i];
                const neighbors = points.slice(i - windowSize, i + windowSize + 1);

                // Check if this is a local maximum (peak) or minimum (valley)
                const isLocalMax = neighbors.every(n => n.distFromCenter <= current.distFromCenter);
                const isLocalMin = neighbors.every(n => n.distFromCenter >= current.distFromCenter);

                // Also check for near-peaks/valleys with small tolerance
                const tolerance = 0.5; // Small tolerance for detecting subtle peaks
                const isNearMax = neighbors.filter(n => n.distFromCenter > current.distFromCenter + tolerance).length === 0;
                const isNearMin = neighbors.filter(n => n.distFromCenter < current.distFromCenter - tolerance).length === 0;

                if (isLocalMax || isLocalMin || (isNearMax && !isNearMin) || (isNearMin && !isNearMax)) {
                    const type = (isLocalMax || isNearMax) ? 'peak' : 'valley';

                    // Avoid duplicate features too close together
                    const tooClose = features.some(f => Math.abs(f.index - current.index) < windowSize);
                    if (!tooClose) {
                        features.push({
                            ...current,
                            type: type
                        });
                    }
                }
            }

            // Third pass: ensure we capture all features plus dense curve sampling
            const finalSamples = [];

            // Add all detected features
            features.forEach(feature => finalSamples.push(feature));

            // Add dense interpolation points between features for smooth curves
            for (let i = 0; i < features.length; i++) {
                const current = features[i];
                const next = features[(i + 1) % features.length];

                // Calculate the arc length between features
                const startT = current.t;
                const endT = next.t > current.t ? next.t : next.t + 1; // Handle wrap-around
                const arcLength = (endT - startT) * pathLength;

                // Use more interpolation points for longer arcs (curves need more detail)
                const baseInterpCount = 6;
                const extraForLength = Math.floor(arcLength / 10); // More points for longer curves
                const interpCount = Math.min(12, baseInterpCount + extraForLength);

                for (let j = 1; j <= interpCount; j++) {
                    let interpT = current.t + (next.t - current.t) * (j / (interpCount + 1));

                    // Handle wrap-around properly
                    if (interpT > 1) {
                        interpT = interpT - 1;
                    }
                    if (interpT < 0) {
                        interpT = interpT + 1;
                    }

                    const interpDistance = interpT * pathLength;
                    const interpPoint = path.getPointAtLength(interpDistance);
                    finalSamples.push({ t: interpT, point: interpPoint });
                }
            }

            // Add additional high-density sampling for very smooth curves
            const denseSamples = 50; // Extra samples for overall smoothness
            for (let i = 0; i < denseSamples; i++) {
                const t = i / denseSamples;
                const distance = t * pathLength;
                const point = path.getPointAtLength(distance);

                // Only add if not too close to existing samples
                const tooClose = finalSamples.some(s => Math.abs(s.t - t) < 0.01);
                if (!tooClose) {
                    finalSamples.push({ t, point });
                }
            }

            // Sort by parameter t and convert to vertices
            finalSamples.sort((a, b) => a.t - b.t);
            const vertices = new Float32Array(finalSamples.length * 2);

            for (let i = 0; i < finalSamples.length; i++) {
                const point = finalSamples[i].point;
                const scaledX = (point.x - centerX) * scale / (maxDimension / 2);
                const scaledY = (point.y - centerY) * scale / (maxDimension / 2);

                vertices[i * 2] = scaledX;
                vertices[i * 2 + 1] = scaledY;
            }

            return vertices;
        }

        function createFallbackShape(index) {
            // Fallback to simple geometric shapes if SVG parsing fails
            switch (index) {
                case 0: return new RoundedPolygon(new Float32Array([0, -40, 35, 20, -35, 20]), 0);
                case 1: return new RoundedPolygon(new Float32Array([-30, -30, 30, -30, 30, 30, -30, 30]), 0);
                case 2: return new RoundedPolygon(new Float32Array([0, -35, 33, -11, 20, 28, -20, 28, -33, -11]), 0);
                case 3: return new RoundedPolygon(new Float32Array([30, 0, 15, 26, -15, 26, -30, 0, -15, -26, 15, -26]), 0);
                case 4: return new RoundedPolygon(new Float32Array([25, -10, 25, 10, 10, 25, -10, 25, -25, 10, -25, -10, -10, -25, 10, -25]), 0);
                case 5: return createCirclePolygon(35, 12);
                case 6: return createStarPolygon(30, 5);
                default: return createCirclePolygon(30, 8);
            }
        }

        function createCirclePolygon(radius, sides) {
            const vertices = new Float32Array(sides * 2);
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI;
                vertices[i * 2] = Math.cos(angle) * radius;
                vertices[i * 2 + 1] = Math.sin(angle) * radius;
            }
            return new RoundedPolygon(vertices, 0);
        }

        function createStarPolygon(radius, points) {
            const vertices = new Float32Array(points * 4);
            const innerRadius = radius * 0.4;
            let vertexIndex = 0;

            for (let i = 0; i < points; i++) {
                const outerAngle = (i / points) * 2 * Math.PI - Math.PI / 2;
                vertices[vertexIndex++] = Math.cos(outerAngle) * radius;
                vertices[vertexIndex++] = Math.sin(outerAngle) * radius;

                const innerAngle = ((i + 0.5) / points) * 2 * Math.PI - Math.PI / 2;
                vertices[vertexIndex++] = Math.cos(innerAngle) * innerRadius;
                vertices[vertexIndex++] = Math.sin(innerAngle) * innerRadius;
            }
            return new RoundedPolygon(vertices, 0);
        }

        function drawMaterial3Container() {
            const centerX = morphCanvas.width / 2;
            const centerY = morphCanvas.height / 2;
            const radius = Math.min(morphCanvas.width, morphCanvas.height) * 0.45;
            const containerPulse = 1 + Math.sin(animationTime * 1.5) * 0.02;

            morphCtx.save();
            morphCtx.translate(centerX, centerY);
            morphCtx.scale(containerPulse, containerPulse);

            morphCtx.beginPath();
            morphCtx.arc(0, 0, radius, 0, 2 * Math.PI);
            morphCtx.fillStyle = 'rgba(103, 80, 164, 0.08)';
            morphCtx.fill();

            morphCtx.strokeStyle = 'rgba(103, 80, 164, 0.15)';
            morphCtx.lineWidth = 1;
            morphCtx.stroke();

            morphCtx.restore();
        }

        function applyMaterial3ExpressiveEffects() {
            animationTime += 0.05;

            if (currentMorph && morphProgress < 1.0) {
                const morphPhase = morphProgress;

                if (morphPhase < 0.8) {
                    discreteSpinSpeed = 6.0;
                } else {
                    const bouncePhase = (morphPhase - 0.8) / 0.2;
                    const speedFactor = 1 - bouncePhase;
                    const bounce = Math.sin(bouncePhase * Math.PI * 2.5);
                    const overshootIntensity = -1.2;

                    discreteSpinSpeed = 6.0 * speedFactor + overshootIntensity * bounce * speedFactor;
                }
            } else {
                discreteSpinSpeed = 0.05;
            }

            rotationAngle += discreteSpinSpeed;
            morphCtx.rotate((rotationAngle * Math.PI) / 180);

            let syncedScale;
            if (currentMorph && morphProgress < 1.0) {
                const morphPhase = morphProgress;
                const baseScale = 0.95;
                let scaleVariation;

                if (morphPhase < 0.8) {
                    scaleVariation = 0.015 + Math.sin(animationTime * 4) * 0.005;
                } else {
                    const bouncePhase = (morphPhase - 0.8) / 0.2;
                    scaleVariation = 0.015 + Math.sin(bouncePhase * Math.PI) * 0.025;
                }
                syncedScale = baseScale + scaleVariation;
            } else {
                syncedScale = 0.96 + Math.sin(animationTime * 1.2) * 0.01;
            }
            morphCtx.scale(syncedScale, syncedScale);

            if (currentMorph && morphProgress < 1.0) {
                pulseValue = 0.8 + morphProgress * 0.2;
            } else {
                pulseValue = 0.7 + Math.sin(animationTime * 3) * 0.2;
            }
        }

        function drawPolygonWithEffects(polygon, color, lineWidth = 2) {
            const alpha = Math.floor(pulseValue * 255).toString(16).padStart(2, '0');
            const pulsedColor = color + alpha;
            drawPolygon(polygon, pulsedColor, lineWidth);
        }

        function drawCubicsWithEffects(cubics, color, lineWidth = 2) {
            const alpha = Math.floor(pulseValue * 255).toString(16).padStart(2, '0');
            const pulsedColor = color + alpha;
            drawCubics(cubics, pulsedColor, lineWidth);
        }

        function drawCurrentShape() {
            morphCtx.clearRect(0, 0, morphCanvas.width, morphCanvas.height);
            drawMaterial3Container();

            morphCtx.save();
            morphCtx.translate(morphCanvas.width / 2, morphCanvas.height / 2);
            applyMaterial3ExpressiveEffects();

            const shape = morphShapes[currentStep - 1];
            drawPolygonWithEffects(shape, '#6750A4', 3);

            morphCtx.restore();
        }

        function drawMorphedShape() {
            morphCtx.clearRect(0, 0, morphCanvas.width, morphCanvas.height);
            drawMaterial3Container();

            morphCtx.save();
            morphCtx.translate(morphCanvas.width / 2, morphCanvas.height / 2);
            applyMaterial3ExpressiveEffects();

            const morphedCubics = currentMorph.asCubics(morphProgress);
            drawCubicsWithEffects(morphedCubics, '#6750A4', 3);

            morphCtx.restore();
        }

        function drawPolygon(polygon, color, lineWidth = 2) {
            drawCubics(polygon.cubics, color, lineWidth);
        }

        function drawCubics(cubics, color, lineWidth = 2) {
            morphCtx.strokeStyle = color;
            morphCtx.lineWidth = lineWidth;
            morphCtx.fillStyle = color + '20';

            morphCtx.beginPath();

            const firstCubic = cubics[0];
            morphCtx.moveTo(firstCubic.anchor0X, firstCubic.anchor0Y);

            for (const cubic of cubics) {
                morphCtx.bezierCurveTo(
                    cubic.control0X, cubic.control0Y,
                    cubic.control1X, cubic.control1Y,
                    cubic.anchor1X, cubic.anchor1Y
                );
            }

            morphCtx.closePath();
            morphCtx.fill();
            morphCtx.stroke();
        }

        function startAnimation() {
            if (isAnimating) return;
            isAnimating = true;

            if (!currentMorph) {
                const startShape = morphShapes[currentStep - 1];
                const endShape = morphShapes[currentStep % morphShapes.length];
                currentMorph = new Morph(startShape, endShape);
            }

            animationInterval = setInterval(() => {
                let morphIncrement;
                if (morphProgress < 0.8) {
                    morphIncrement = 0.03;
                } else {
                    const easeOutFactor = 1 - (morphProgress - 0.8) / 0.2;
                    morphIncrement = 0.03 * easeOutFactor;
                    morphIncrement = Math.max(morphIncrement, 0.001);
                }
                morphProgress += morphIncrement;

                if (morphProgress >= 1.0) {
                    morphProgress = 0;
                    currentStep = currentStep >= morphShapes.length ? 1 : currentStep + 1;

                    const startShape = morphShapes[currentStep - 1];
                    const endShape = morphShapes[currentStep % morphShapes.length];
                    currentMorph = new Morph(startShape, endShape);
                }

                drawMorphedShape();
            }, 16);
        }

        // Initialize everything
        document.addEventListener('DOMContentLoaded', () => {
            initializeModules();
        });
    </script>
</body>
</html>